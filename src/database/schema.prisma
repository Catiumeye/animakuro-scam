generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String        @id @db.Uuid
  username             String        @unique @db.VarChar(64)
  email                String        @db.VarChar(320)
  avatar               String?
  is_email_confirmed   Boolean       @default(false)
  password             String        @map("password")
  created_at           DateTime      @default(now()) @map("created_at") @db.Date
  deleted              Boolean       @default(false)
  is_social            Boolean
  auth                 Auth[]
  auth_sessions        AuthSession[]
  rating_anime         RatingAnime[]
  user_collection      UserFolder[]  @relation("user_collection")
  user_folders         UserFolder[]  @relation("user_folder")
  user_profile         UserProfile?
  favourite_animes     Anime[]       @relation("AnimeToUser")
  favourite_authors    Author[]      @relation("AuthorToUser")
  favourite_characters Character[]   @relation("CharacterToUser")
  favourite_genres     Genre[]       @relation("GenreToUser")
  favourite_studios    Studio[]      @relation("StudioToUser")

  @@map("users")
}

model Auth {
  id           String   @id @default(uuid())
  type         AuthType
  uuid         String   @db.VarChar(64)
  access_token String   @db.VarChar(320)
  username     String   @unique @db.VarChar(64)
  email        String?  @db.VarChar(320)
  avatar       String?
  updated_at   DateTime @default(now()) @map("updated_at")
  created_at   DateTime @default(now()) @map("created_at")
  user_id      String   @db.Uuid
  user         User     @relation(fields: [user_id], references: [id])

  @@map("auth")
}

model AuthSession {
  id      String  @id @default(uuid())
  agent   String
  ip      String  @db.VarChar(64)
  active  Boolean @default(true)
  user_id String  @db.Uuid
  user    User    @relation(fields: [user_id], references: [id])

  @@map("auth_session")
}

model Studio {
  id                  String   @id @db.Uuid
  created_at          DateTime @default(now()) @map("created_at")
  updated_at          DateTime @default(now()) @map("updated_at")
  name                String   @db.VarChar(64)
  rating              Float    @db.Real
  thumbnail           String
  anime_count         Float    @default(0) @db.Real
  anime_starts        Float    @db.Real
  anime_ends          Float    @db.Real
  is_animation_studio Boolean  @default(true)
  animes              Anime[]  @relation("AnimeToStudio")
  favourite_by        User[]   @relation("StudioToUser")

  @@map("studio")
}

model Friendship {
  friend_one String           @db.Uuid
  friend_two String           @db.Uuid
  status     FriendshipStatus @default(AWAITING)
  start_date DateTime         @default(now()) @db.Date

  @@unique([friend_one, friend_two])
  @@map("friendship")
}

model Anime {
  id                 String           @id @db.Uuid
  title              String           @db.VarChar(100)
  score              Float            @db.Real
  year               Int              @db.SmallInt
  date_start         DateTime?        @db.Date
  date_end           DateTime?        @db.Date
  country_of_origin  String           @db.VarChar(2)
  format             MediaFormat      @default(OTHER)
  source             MediaSource      @default(OTHER)
  season             YearSeason       @default(FALL)
  type               AnimeType        @default(ANIME)
  hashtags           String[]
  synonyms           String[]
  is_licensed        Boolean
  seasons_count      Int              @db.SmallInt
  episodes           Int              @db.SmallInt
  duration           Int
  next_episode       DateTime
  rating             FilmRating       @default(G)
  description        String
  preview_link       String
  status_description String           @db.VarChar(30)
  release_status     ReleaseStatus    @default(COMPLETED)
  created_at         DateTime         @default(now()) @map("created_at")
  updated_at         DateTime         @default(now()) @map("updated_at")
  evaluation         String           @default("5:0;4:0;3:0;2:0;1:0")
  airing_schedule    AiringSchedule[]
  opening_ending     OpeningEnding[]
  ratingAnime        RatingAnime[]
  relating_animes    RelatingAnime[]  @relation("relating")
  related_by_animes  RelatingAnime[]  @relation("related")
  similar_animes     SimilarAnime[]   @relation("similar")
  similar_by_animes  SimilarAnime[]   @relation("similar_by")
  authors            Author[]         @relation("AnimeToAuthor")
  characters         Character[]      @relation("AnimeToCharacter")
  genres             Genre[]          @relation("AnimeToGenre")
  studios            Studio[]         @relation("AnimeToStudio")
  favourite_by       User[]           @relation("AnimeToUser")
  user_folders       UserFolder[]     @relation("AnimeToUserFolder")

  @@map("anime")
}

model RelatingAnime {
  child_anime_id  String        @db.Uuid
  parent_anime_id String        @db.Uuid
  status          AnimeRelation @default(NULL)
  child_anime     Anime         @relation("relating", fields: [child_anime_id], references: [id], onDelete: Cascade)
  parent_anime    Anime         @relation("related", fields: [parent_anime_id], references: [id], onDelete: Cascade)

  @@id([child_anime_id, parent_anime_id])
  @@map("relating_anime")
}

model SimilarAnime {
  child_anime_id  String        @db.Uuid
  parent_anime_id String        @db.Uuid
  status          AnimeApproval @default(PENDING)
  child_anime     Anime         @relation("similar", fields: [child_anime_id], references: [id], onDelete: Cascade)
  parent_anime    Anime         @relation("similar_by", fields: [parent_anime_id], references: [id], onDelete: Cascade)

  @@id([child_anime_id, parent_anime_id])
  @@map("similar_anime")
}

model AiringSchedule {
  id         String   @id @db.Uuid
  airing_at  DateTime
  name       String   @db.VarChar(100)
  episode    Int      @db.SmallInt
  anime_id   String   @db.Uuid
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @default(now()) @map("updated_at")
  anime      Anime    @relation(fields: [anime_id], references: [id], onDelete: Cascade)

  @@map("airing_schedule")
}

model Author {
  id                  String   @id @db.Uuid
  name                String   @db.VarChar(50)
  primary_occupations String[]
  age                 Int
  date_of_birth       String   @db.VarChar(30)
  date_of_death       String   @db.VarChar(30)
  synonyms            String[]
  years_active        String[]
  home_town           String   @db.VarChar(30)
  blood_type          String   @db.VarChar(30)
  language            String   @db.VarChar(30)
  gender              String   @db.VarChar(30)
  bio                 String
  created_at          DateTime @default(now()) @map("created_at")
  updated_at          DateTime @default(now()) @map("updated_at")
  animes              Anime[]  @relation("AnimeToAuthor")
  favourite_by        User[]   @relation("AuthorToUser")

  @@map("author")
}

model Character {
  id            String        @id @db.Uuid
  name          String        @db.VarChar(50)
  gender        String        @db.VarChar(30)
  blood_type    String        @db.VarChar(30)
  date_of_birth String        @db.VarChar(30)
  age           Int
  synonyms      String[]
  importance    CharacterType @default(PROTAGONIST)
  role          CharacterRole @default(MAIN)
  description   String
  created_at    DateTime      @default(now()) @map("created_at")
  updated_at    DateTime      @default(now()) @map("updated_at")
  animes        Anime[]       @relation("AnimeToCharacter")
  favourite_by  User[]        @relation("CharacterToUser")

  @@map("character")
}

model Genre {
  id           String  @id @db.Uuid
  name         String  @db.VarChar(50)
  description  String?
  animes       Anime[] @relation("AnimeToGenre")
  favourite_by User[]  @relation("GenreToUser")

  @@map("genre")
}

model Translation {
  id          String @id @db.Uuid
  language    String @db.VarChar(20)
  translation String

  @@map("translation")
}

model UserProfile {
  id               String           @id @db.Uuid
  user_id          String           @unique @db.Uuid
  created_at       DateTime?        @default(now()) @db.Date
  profile_settings ProfileSettings?
  user             User             @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("user_profile")
}

model ProfileSettings {
  id             String           @id @db.Uuid
  profile_id     String           @unique @db.Uuid
  displayed_name String?          @db.VarChar(30)
  gender         Gender           @default(UNSPECIFIED)
  birthday       DateTime?        @db.Date
  site_theme     SiteTheme        @default(AUTO)
  avatar_id      String?          @unique @db.Uuid
  cover_id       String?          @unique @db.Uuid
  country        ProfileCountries @default(UNSPECIFIED)
  language       ProfileLanguages @default(ENGLISH)
  about          String?
  timezone       String?          @db.VarChar(7)
  moderator_role ModeratorRoles   @default(VIEWER)
  is_blocked     Boolean          @default(false)
  profile_type   ProfileType      @default(PUBLIC)
  integrations   Json             @db.Json
  notifications  Json             @db.Json
  subscribe_tier SubscribeTier    @default(FREE_ACCOUNT)
  updated_at     DateTime         @default(now()) @map("updated_at")
  profile        UserProfile      @relation(fields: [profile_id], references: [id], onDelete: Cascade)

  @@map("profile_settings")
}

model UserFolder {
  id                  String     @id @db.Uuid
  user_id             String     @db.Uuid
  is_collection       Boolean    @default(false)
  is_public           Boolean    @default(false)
  name                String     @db.VarChar(25)
  description         String
  created_at          DateTime   @default(now()) @map("created_at")
  updated_at          DateTime   @default(now()) @map("updated_at")
  user_collection_id  String?    @db.Uuid
  is_statistic_active Boolean    @default(false)
  type                FolderType @default(DEFAULT)
  user_collection     User?      @relation("user_collection", fields: [user_collection_id], references: [id])
  user                User       @relation("user_folder", fields: [user_id], references: [id])
  animes              Anime[]    @relation("AnimeToUserFolder")

  @@map("user_folder")
}

model OpeningEnding {
  id            String            @id @db.Uuid
  anime_id      String            @db.Uuid
  type          OpeningEndingType
  url           String            @db.VarChar(2048)
  name          String            @db.VarChar(100)
  author_name   String            @db.VarChar(100)
  episode_start Int               @db.SmallInt
  episode_end   Int               @db.SmallInt
  created_at    DateTime          @default(now()) @map("created_at")
  updated_at    DateTime          @default(now()) @map("updated_at")
  anime         Anime             @relation(fields: [anime_id], references: [id], onDelete: Cascade)

  @@map("opening_ending")
}

model RatingAnime {
  user_id  String @db.Uuid
  anime_id String @db.Uuid
  rating   Int
  anime    Anime  @relation(fields: [anime_id], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@id([anime_id, user_id])
  @@map("rating_anime")
}

enum OpeningEndingType {
  OPENING
  ENDING
}

enum FriendshipStatus {
  AWAITING
  REQUESTED
  CONFIRMED
}

enum AnimeRelation {
  DIRECT
  CHRONOLOGY
  FRANCHISE
  NULL
}

enum Gender {
  UNSPECIFIED
  MALE
  FEMALE
  OTHER
}

enum AnimeApproval {
  PENDING
  APPROVED
}

enum FilmRating {
  G
  PG
  PG_13
  R
  R_17
  NC_17
  NC_21
}

enum MediaSource {
  ORIGINAL
  MANGA
  LIGHT_NOVEL
  VISUAL_NOVEL
  VIDEO_GAME
  OTHER
  NOVEL
  DOUJINSHI
  ANIME
  WEB_NOVEL
  LIVE_ACTION
  GAME
  COMIC
  MULTIMEDIA_PROJECT
  PICTURE_BOOK
}

enum ReleaseStatus {
  COMPLETED
  ANNOUNCEMENT
  RELEASING
  AIRING
  NOT_YET_RELEASED
  CANCELLED
  HIATUS
}

enum MediaFormat {
  TV
  TV_SHORT
  MOVIE
  SPECIAL
  OVA
  ONA
  MUSIC
  MANGA
  NOVEL
  ONE_SHOT
  OTHER
}

enum YearSeason {
  FALL
  SUMMER
  SPRING
  WINTER
}

enum AnimeType {
  ANIME
  MANGA
}

enum CharacterType {
  PROTAGONIST
  ANTAGONIST
  SIDEKICK
  ORBITAL_CHARACTER
  LOVE_INTEREST
  CONFIDANTE
  EXTRAS
  FOIL
  OTHER
}

enum CharacterRole {
  MAIN
  SUPPORTING
  BACKGROUND
}

enum AuthType {
  JWT
  DISCORD
  GOOGLE
  APPLE
  FACEBOOK
}

enum ModeratorRoles {
  ADMIN
  MODERATOR
  CONTENT_FILLER
  OTHER_STAFF
  VIEWER
}

enum SubscribeTier {
  FREE_ACCOUNT
  BASIC
  SILVER
  GOLD
  PLATINUM
}

enum ProfileLanguages {
  ENGLISH
  RUSSIAN
  JAPANESE
  UKRAINIAN
}

enum ProfileCountries {
  USA
  RUSSIA
  JAPAN
  UKRAINE
  UNSPECIFIED
}

enum SiteTheme {
  LIGHT
  DARK
  AUTO
}

enum ProfileType {
  PUBLIC
  PRIVATE
}

enum Media {
  ANIMES
  STUDIOS
  CHARACTERS
  AUTHORS
  GENRES
}

enum FolderType {
  LOOKING
  ABANDONED
  PLANNED
  VIEWED
  DEFAULT
}
