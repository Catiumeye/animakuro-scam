generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions", "referentialActions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String            @id @default(uuid()) @db.Uuid
  username            String            @unique @db.VarChar(64)
  email               String?           @db.VarChar(320)
  is_email_confired   Boolean           @default(false)
  password            String            @map("password")
  secret2fa           String?           @db.VarChar(20)
  birthday            DateTime?         @db.Date
  gender              Gender            @default(UNSPECIFIED)
  created_at          DateTime          @default(now()) @map("created_at") @db.Date
  deleted             Boolean           @default(false)
  third_party_auth    ThirdPartyAuth?   @relation(fields: [third_party_auth_id], references: [id])
  third_party_auth_id String?           @map("third_party_auth_id")
  user_profile        UserProfile? //o-2-o relation. Field name changed 28/12 from user_profile
  site_auth_sessions  SiteAuthSession[]

  @@map("users")
}

model SiteAuthSession {
  id      String  @id @default(uuid())
  agent   String  @db.Text
  ip      String  @db.VarChar(64)
  user_id String  @map("user_id") @db.Uuid
  user    User    @relation(fields: [user_id], references: [id])
  active  Boolean @default(true)

  @@map("site_auth_session")
}

model ThirdPartyAuth {
  id         String         @id @default(uuid())
  uid        String         @db.VarChar(64)
  email      String?        @db.VarChar(320)
  first_name String?        @map("first_name") @db.VarChar(64)
  last_name  String?        @map("last_name") @db.VarChar(64)
  avatar     String?        @db.Text
  type       ThirdPartyType
  user       User[]
  deleted    Boolean        @default(false)
  created_at DateTime       @default(now()) @map("created_at")

  @@map("third_party_auth")
}

model Studio {
  id           String   @id @default(uuid()) @db.Uuid
  created_at   DateTime @default(now()) @map("created_at")
  studio_name  String   @db.VarChar(64)
  rating       Float    @db.Real
  thumbnail    String   @db.Text
  anime_count  Float    @default(0) @db.Real
  anime_starts Float    @db.Real
  anime_ends   Float    @db.Real
  anime        Anime[]

  @@map("studio")
}

model Friendship {
  friend_one String           @db.Uuid
  friend_two String           @db.Uuid
  status     FriendshipStatus @default(AWAITING)
  start_date DateTime         @default(now()) @db.Date

  @@unique([friend_one, friend_two])
  @@map("friendship")
}

model Anime {
  id                 String          @id @default(uuid()) @db.Uuid
  title              String          @db.VarChar(100)
  score              Float           @db.Real
  year               Int             @db.SmallInt
  date_start         DateTime?       @db.Date
  date_end           DateTime?       @db.Date
  country_of_origin  String          @db.VarChar(2)
  genres             Genre[]
  format             MediaFormat     @default(OTHER)
  source             MediaSource     @default(OTHER)
  season             YearSeason      @default(FALL)
  type               AnimeType       @default(ANIME)
  hashtags           String[]
  synonyms           String[]
  is_licensed        Boolean
  seasons_count      Int             @db.SmallInt
  episodes           Int             @db.SmallInt
  duration           Int             @db.Integer
  next_episode       DateTime        @db.Time
  rating             FilmRating      @default(G)
  description        String          @db.Text
  preview_link       String          @db.Text
  status_description String          @db.VarChar(30)
  release_status     ReleaseStatus   @default(COMPLETED)
  studios            Studio[]
  characters         Character[]
  authors            Author[]
  relating_animes    RelatingAnime[] @relation("relating")
  related_by_animes  RelatingAnime[] @relation("related")
  similar_animes     SimilarAnime[]  @relation("similar")
  similar_by_animes  SimilarAnime[]  @relation("similar_by")
  user_anime         UserAnime[]

  @@map("anime")
}

model RelatingAnime {
  child_anime     Anime         @relation("relating", fields: [child_anime_id], references: [id], onDelete: Cascade)
  child_anime_id  String        @db.Uuid
  parent_anime    Anime         @relation("related", fields: [parent_anime_id], references: [id], onDelete: Cascade)
  parent_anime_id String        @db.Uuid
  status          AnimeRelation @default(NULL)

  @@id([child_anime_id, parent_anime_id])
  @@map("relating_anime")
}

model SimilarAnime {
  child_anime     Anime         @relation("similar", fields: [child_anime_id], references: [id], onDelete: Cascade)
  child_anime_id  String        @db.Uuid
  parent_anime    Anime         @relation("similar_by", fields: [parent_anime_id], references: [id], onDelete: Cascade)
  parent_anime_id String        @db.Uuid
  status          AnimeApproval @default(PENDING)

  @@id([child_anime_id, parent_anime_id])
  @@map("similar_anime")
}

model Author {
  id          String  @id @default(uuid()) @db.Uuid
  author_name String  @db.VarChar(50)
  bucket_id   String  @db.Uuid
  bio         String  @db.Text
  animes      Anime[]

  @@map("author")
}

model Character {
  id             String        @id @default(uuid()) @db.Uuid
  bucket_id      String        @db.Uuid
  character_name String        @db.VarChar(50)
  importance     CharacterType @default(PROTAGONIST)
  role           CharacterRole @default(MAIN)
  description    String        @db.Text
  animes         Anime[]

  @@map("character")
}

model Genre {
  id         String  @id @default(uuid()) @db.Uuid
  genre_name String  @db.VarChar(50)
  animes     Anime[]

  @@map("genre")
}

model Translation {
  id          String @id @default(uuid()) @db.Uuid
  language    String @db.VarChar(20)
  translation String @db.Text

  @@map("translation")
}

// Модели частных индивидуальных баз
model UserProfile {
  id                 String           @id @default(uuid()) @db.Uuid
  user               User             @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id            String           @unique @db.Uuid //Field name changed 28/12 from user_id
  displayed_name     String?          @db.VarChar(30)
  profile_picture_id String?          @db.Uuid // аватар!
  banner_image       String?          @db.Uuid
  about              String?          @db.Text
  country            ProfileCountries @default(UNSPECIFIED)
  language           ProfileLanguages @default(ENGLISH)
  created_at         DateTime?        @default(now()) @db.Date
  subscribe_tier     SubscribeTier    @default(FREE_ACCOUNT)
  moderator_role     ModeratorRoles   @default(VIEWER)
  is_blocked         Boolean          @default(false)
  user_anime         UserAnime? // o-2-o relation. Field name changed 28/12 from user_anime

  @@map("user_profile")
}

model UserAnime {
  // прошу не удалять мои комменты, я удалю их сам, когда утвердим модель.
  id               String       @id @default(uuid()) @db.Uuid
  //  блок привязок - ИЗМЕНЕНЫ названия полей со snake_case на camelCase во избежание ошибок
  user_profile     UserProfile? @relation(fields: [user_profile_id], references: [id], onDelete: Cascade)
  user_profile_id  String       @unique @db.Uuid // o-2-o relation
  anime            Anime?       @relation(fields: [anime_id], references: [id])
  anime_id         String       @db.Uuid
  // информативный блок
  status           WatchStatus  @default(WATCHING)
  in_favourites    Boolean      @default(false)
  // блок для аниме со статусом WATCHING
  season           Int?         @db.SmallInt // какой сезон данного аниме смотрит юзер
  episode          Int?         @db.SmallInt // какой эпизод(серию)
  episode_duration Int?         @db.Integer // секунды: продолжительность этого эпизода
  watched_duration Int?         @db.Integer // секунды: сколько просмотрел из этой серии

  @@map("user_anime")
}

enum FriendshipStatus {
  AWAITING
  REQUESTED
  CONFIRMED
}

enum AnimeRelation {
  DIRECT
  CHRONOLOGY
  FRANCHISE
  NULL
}

enum WatchStatus {
  WATCHING // Currently watching
  PLANNED // Planned to watch
  COMPLETED // renamed from SEEN. Finished watching
  DROPPED // renamed from ABANDONED. Stopped watching before completing
}

enum Gender {
  UNSPECIFIED
  MALE
  FEMALE
  OTHER
}

enum AnimeApproval {
  PENDING
  APPROVED
}

enum FilmRating {
  G
  PG
  PG_13
  R
  R_17
  NC_17
  NC_21
}

enum MediaSource {
  ORIGINAL // An original production not based of another work
  MANGA // Asian comic book
  LIGHT_NOVEL // Written work published in volumes
  VISUAL_NOVEL // Video game driven primary by text and narrative
  VIDEO_GAME // Video game
  OTHER // Other
  NOVEL // Written works not published in volumes
  DOUJINSHI // Self-published works
  ANIME // Japanese Anime
  WEB_NOVEL // Written works published online
  LIVE_ACTION // Live action media such as movies or TV show
  GAME // Games excluding video games
  COMIC // Comics excluding manga
  MULTIMEDIA_PROJECT // Multimedia project
  PICTURE_BOOK // Picture book
}

enum ReleaseStatus {
  COMPLETED // Has completed and is no longer being released
  ANNOUNCEMENT
  RELEASING // Currently releasing
  AIRING
  NOT_YET_RELEASED // To be released at a later date
  CANCELLED // Ended before the work could be finished
  HIATUS // Is currently paused from releasing and will resume at a later date
}

enum MediaFormat {
  TV
  TV_SHORT
  MOVIE
  SPECIAL
  OVA
  ONA
  MUSIC
  MANGA
  NOVEL
  ONE_SHOT
  OTHER
}

enum YearSeason {
  FALL
  SUMMER
  SPRING
  WINTER
}

enum AnimeType {
  ANIME
  MANGA
}

enum CharacterType {
  PROTAGONIST
  ANTAGONIST
  SIDEKICK
  ORBITAL_CHARACTER
  LOVE_INTEREST
  CONFIDANTE
  EXTRAS
  FOIL
  OTHER
}

enum CharacterRole {
  MAIN // Primary role
  SUPPORTING // Supporting role
  BACKGROUND // Background role
}

enum ThirdPartyType {
  DISCORD
  GOOGLE
  APPLE
  FACEBOOK
}

enum ModeratorRoles {
  ADMIN // admin
  MODERATOR // moderator
  CONTENT_FILLER // content maker
  OTHER_STAFF // other worker
  VIEWER // user
}

enum SubscribeTier {
  FREE_ACCOUNT // free
  BASIC // base subscription
  SILVER // silver subscription
  GOLD // gold subscription
  PLATINUM // platinum subscription
}

enum ProfileLanguages {
  ENGLISH
  RUSSIAN
  JAPANESE
  UKRAINIAN
}

enum ProfileCountries {
  USA
  RUSSIA
  JAPAN
  UKRAINE
  UNSPECIFIED
}
